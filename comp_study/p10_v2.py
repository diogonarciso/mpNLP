# %% Libraries
import numpy as np

#%% Partial derivatives of objective function
def partial_deriv(x):
    return [2*x[0]**3 + 1/2*x[0]**2 + 4*x[0] - 13/2,
            2*x[1]**3 + 1/2*x[1]**2 + 4*x[1] - 13/2,
            2*x[2]**3 + 1/2*x[2]**2 + 4*x[2] - 13/2,
            2*x[3]**3 + 1/2*x[3]**2 + 4*x[3] - 13/2,
            2*x[4]**3 + 1/2*x[4]**2 + 4*x[4] - 13/2,
            2*x[5]**3 + 1/2*x[5]**2 + 4*x[5] - 13/2,
            2*x[6]**3 + 1/2*x[6]**2 + 4*x[6] - 13/2,
            2*x[7]**3 + 1/2*x[7]**2 + 4*x[7] - 13/2,
            2*x[8]**3 + 1/2*x[8]**2 + 4*x[8] - 13/2,
            2*x[9]**3 + 1/2*x[9]**2 + 4*x[9] - 13/2]

#%% Jacobian of partial derivatives function
def jac_partial_deriv(x):
    return np.array([[6*x[0]**2 + x[0] + 4, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 6*x[1]**2 + x[1] + 4, 0, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 6*x[2]**2 + x[2] + 4, 0, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 6*x[3]**2 + x[3] + 4, 0, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 6*x[4]**2 + x[4] + 4, 0, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 6*x[5]**2 + x[5] + 4, 0, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 6*x[6]**2 + x[6] + 4, 0, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 6*x[7]**2 + x[7] + 4, 0, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 6*x[8]**2 + x[8] + 4, 0],
                     [0, 0, 0, 0, 0, 0, 0, 0, 0, 6*x[9]**2 + x[9] + 4]])

#%% Constraints on optimization variables (A x <= b + F theta):
A = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
              [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
              [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])

b = np.array( [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] )

F = np.array([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
              [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
              [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
              [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
              [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
              [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])

feas_space_constr = {'A':A, 'b':b, 'F':F}

#%% Space of parameters P_A theta <= P_b:
P_A = np.array([[-1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                [ 0,-1, 0, 0, 0, 0, 0, 0, 0, 0],
                [ 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
                [ 0, 0,-1, 0, 0, 0, 0, 0, 0, 0],
                [ 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
                [ 0, 0, 0,-1, 0, 0, 0, 0, 0, 0],
                [ 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
                [ 0, 0, 0, 0,-1, 0, 0, 0, 0, 0],
                [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
                [ 0, 0, 0, 0, 0,-1, 0, 0, 0, 0],
                [ 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
                [ 0, 0, 0, 0, 0, 0,-1, 0, 0, 0],
                [ 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
                [ 0, 0, 0, 0, 0, 0, 0,-1, 0, 0],
                [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
                [ 0, 0, 0, 0, 0, 0, 0, 0,-1, 0],
                [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
                [ 0, 0, 0, 0, 0, 0, 0, 0, 0,-1],
                [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])

P_b = np.array([0, 2, -2, 3, -2, 3, -2, 3, -2, 3, -2, 3, -2, 3, -2, 3, -2, 3, -2, 3])

par_space_constr = {'P_A':P_A, 'P_b':P_b}

#%% Bounds for optimization problems
bnds_theta = (0, 3)
